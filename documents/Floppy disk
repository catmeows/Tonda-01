Tonda01 uses 35 track single density single drive.
Tracks are numbered 0 to 34.
Each track has single sector of 3072 bytes.
Track 0 contains disk catalogue, tracks 1-34 contains data.
Single side of disk can store 104448 bytes.


Interfacing:


Track structure:
 Header: 16*pilot byte + 3 bytes $D5 $F5 $B5 + 1 byte with track id + 1 byte with track id (for verification) + 1*byte $D5
 Data: 16*pilot byte + 3 bytes $D5 $F5 $BD + 2816 bytes of data + 2 bytes of CRC + 1*byte $D5
 
 regular data - 1x1x 1x1x
 $D5 -          1101 0101
 $F5 -          1111 0101
 $B5 -          1011 0101
 $BD -          1011 1101
 
Catalogue - track 0 (840B):
 Disk header (20B)
 34x File entry (782B)
 Track map (34B)
 
 Disk header (20B)
 Diskname        16B
 Free             1B how many tracks are free
 Version          1B version of disk format
 Reserved         2B reserved
 
  
 File entry (23B):
 Filename        16B 
 Type             1B  B-Basic, C-Code, V-variable, S-Screen, $00-empty, $01-deleted
 Length           2B
 Attribute        2B  
 Start track      1B
 Flag             1B  00-normal, 01-write protected
 
 Track map:
 34 bytes
 Values: $00       unused
         $01-$7F   next track
         $FE       deleted
         $FF       bad  
 
 
Controller has following properties:
 Reading/writing one bit takes 4us ~ 7 cycles.
 Reading/writing one byte takes 28us ~ 49 cycles
 Reading/writing one byte takes 32us ~ 56 cycles

 Reading disk:
 Setting ReadDisk line low.
 It reads bits and shift them into 8 bit shift register until b7 (most significant bit) of shift register is set to '1'.
 When b7 is set, incoming zeroes are ignored.
 When next bit is '1', controller waits for another bit X then clears shift register, shift '1' and then X into shift register.
 That allows CPU to poll shift register content until b7 is set and then read a byte.

   read_floppy
      LDA $BFFE         ;5 floppy data port
      BPL read_floppy   ;3 wait till byte is complete (bit 7 set)
                        ;after b7 is set, controller will wait for '1' and 'X' bits before clearing register, giving at most 14 cycles to exit polling loop
                        
 Using pilot "byte" 11111110b (8bits) controller can synchronize. It takes 7 pilot bytes to be fully synchronized.
 
 Regular bytes are encode as 7-bit GCR scheme:
 
1010101 - 0
1010110 - 1
1010111 - 2
1011010 - 3
1011011 - 4
1011101 - 5
1011110 - 6
1011111 - 7
1101010 - 8
1101011 - 9
1101101 - A
1101110 - B
1101111 - C
1110101 - D
1110110 - E
1110111 - F
1111010 - MARK0  
1111011 - MARK1
1111101 - MARK2 
1111110 -
1111111 - SYNC
 
 State machine programs
 
   STD FD_WRITE   ;PC,opcode
                 ;PC+1               WRITE LOAD             SHIFT                 RESET         
                 ;PC+2               '0'         '1'        '0'         '1'       '0'/'1'        
                 ;$FFFF           0  NOP         NOP        NOP         NOP       SR,JMP 1    
                 ;EA, rA          1  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;EA+1, rB        2  LOAD        LOAD       SHL0        SHL0      SR,JMP 1
  STA FD_WRITE   ;PC, opcode      3  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;PC+1            4  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;PC+2            5  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;$FFFF           6  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;EA, rA          7  JMP 1       NOP        JMP 1       NOP       SR,JMP 1
                 ;                8  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;                9  LOAD        LOAD       SHL0        SHL0      SR,JMP 1
                 ;                A  NOP         NOP        NOP         NOP       SR,JMP 1      
                 ;                B  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;                C  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;                D  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;                E  JMP 8       JMP 1      JMP 8       JMP 1     SR,JMP 1
                 ;                F  NOP         NOP        NOP         NOP       SR,JMP 1
                 ;                

                 ;                   BIT0        BIT0       BIT1        BIT1
                 ;                   PULSE0      PULSE1     PULSE0      PULSE1 
                 ;
                 ;                0  NOP         NOP        NOP,JMP0    NOP
                 ;                1  NOP         NOP        NOP         NOP
                 ;                2  NOP         NOP        NOP         NOP
                 ;                3  NOP         JMP A      NOP         JMP D
                 ;                4  NOP         JMP A      NOP         JMP D 
                 ;                5  NOP         JMP A      NOP         JMP D
                 ;                6  NOP         JMP A      NOP         JMP D
                 ;                7  NOP         JMP A      NOP         JMP D
                 ;                8  NOP         JMP A      NOP         JMP D
                 ;                9  SHL0,JMP 0  JMP A      CLR,JMP B   JMP D
                 ;                A  SHL1,JMP 0  SHL1,JMP 0 JMP 0       JMP 0             
                 ;                B  SHL1        SHL1       JMP 0       JMP 0
                 ;                C  SHL0,JMP 2  SHL0,JMP 2 JMP 0       JMP 0                 
                 ;                D  SHL1        SHL1       CLR,JMP D   CLR,JMP D 
                 ;                E  SHL1,JMP 2  SHL1,JMP 2 JMP 0       JMP 0
                 ;                F  JMP 0       JMP 0      JMP 0       JMP 0
 
 
 
 
 
 Writting disk:
 
   write_sync
      STA $BFFE         ;write data byte
      LDA #DISK_MODE    ;xxxx1|111 set sync mode
      STA $BFFF         ;set sync mode bit
                        ;this must be done before data are shifted out
   write_ack                      
      LDA $BFFF         ;read control byte
      ANDA #$08         ;AND xxxxAxxx
      BNE write_ack
                        ;continue


      LDA #DISK_MODE    ;2 xxxx0|111 set data mode
      STA $BFFF         ;5 reset sync mode bit
   write_data_loop
      LDA ,X+           ;7
   write_data
      STA $BFFE         ;5 write data byte
      LDA #$08
   write_dack
      BIT $BFFF         ;5
      BEQ write_dack    ;3 wait for ack (max delay 13 cycles)
                        ;  continue
      LEAY -1,Y         ;5  decrease counter
      BNE write_data_loop ;3
      
                        ;ack to ack = 13 delay + 8 loop + 12 write + 2 setup + 13 delay = 48 (less than 56) 
 
 Track 0 sensor
    LDA $BFFF           ;read control register
    BITA #04            ;test track 0 bit
    BNE track0detected
    
 Write protect sensor
    LDA $BFFF
    BITA #02
    BNE writeProtected
    
Disk exists
    LDA $BFFF
    BITA #$01
    BNE diskExists
    
    
      
      
 
 Pseudo code for reading data from single track/sector:
 
 _read_sector
          set ReadDisk line low
 _read_header
          read pilot subroutine
          check if next byte is $B5
          if not $B5 jump back to read header
          read 3 bytes into temporary area
          check that 3rd byte is $D5
          check that 1st byte xor 2nd byte is zero
          now, 1st byte is current track
          check we are on correct track, exit if no
 _read_data
          read pilot subroutine
          check if next byte is $AD
          if not go back to _read_data
          read 2816 bytes of data + 2 bytes of crc + 1 byte $D5
          compute crc, check last byte is $D5
          end
          
 _read_pilot
         read byte subroutine
         if byte is not $FF jump back to _read_pilot
 _read_pilot_sync        
         read byte subroutine
         if byte is $FF jump back to _read_pilot_sync
         if byte is not $D5 jump back to _read_pilot
         read byte subroutine
         if byte is not $F5 jump back to _read_pilot
         exit
         
 _read_byte
         poll shift register
         if bit 7 is set then increase byte_read_count and exit
         otherwise jump back to _read_byte
          
 timeout mechanism:
         fail read pilot after reading 65535 bytes (little bit more than eleven revolutions)
         
         
         
          
 
 Writing disk:
 Setting WriteDisk line low.
 When controller finds out WriteDisk line is low, it reads byte (8 bits) from data latch and reads 1 bit from signal pilot latch.
 Controller shifts all 8 bits to disk, if bit in signal pilot latch is set, it will write additional '0'. After last bit written, controller reads another byte from data latch and bit from signal pilot latch.
 
 Pseudo code
 
 _write_sector (assuming we are on correct track)
        jump to read header subroutine
        set read line high
        set write line low
        repeat 16 times:
          put $FF into data latch
          put '1' into pilot signal latch
          read shift register
          wait until lower 7 bits are reset: that means controller is going to output either 
                        1D (data byte with lowest bit reset) or 
                        D (data byte with lowest bit set) or 
                        10 (pilot signal)
                        in all cases controller will read data/pilot latch within no more than 2*4us ~ 14 cycles
                        wait some time and jump to repeat
        
       
        
 
